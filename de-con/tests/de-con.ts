import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import assert from "assert";
import { DeCon } from "../target/types/de_con";

describe("de-con", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  // Use the program workspace entry generated by Anchor
  const program = anchor.workspace.de_con as Program<DeCon>;

  it("creates a Question with ask_question", async () => {
    const questionKeypair = anchor.web3.Keypair.generate();

    const questionText = "Will it rain tomorrow?";
    const description = "Short weather prediction";
    const fund = new anchor.BN(1000);
    const dateResolved = "2025-12-31";
    const imgUrl = "https://example.com/image.png";

    await program.methods
      .askQuestion(questionText, description, fund, dateResolved, imgUrl)
      .accounts({
        question: questionKeypair.publicKey,
        user: program.provider.publicKey!,
      })
      .signers([questionKeypair])
      .rpc();

    const q = await program.account.question.fetch(questionKeypair.publicKey);
    assert.strictEqual(q.question, questionText);
    assert.strictEqual(q.description, description);
    // fund is a u64 in Rust; Anchor maps that to BN in JS
    assert.ok(q.fund.eq(fund));
    assert.strictEqual(q.dateResolved, dateResolved);
    assert.strictEqual(q.imgUrl, imgUrl);
    assert.ok(q.yesVotes.toNumber() === 0);
    assert.ok(q.noVotes.toNumber() === 0);
    // bets should be an empty vector initially
    assert.ok(Array.isArray(q.bets) && q.bets.length === 0);
  });

  it("places a bet and records Bet account", async () => {
    // First create a question to bet on
    const questionKeypair = anchor.web3.Keypair.generate();
    await program.methods
      .askQuestion(
        "Is 2+2=4?",
        "Simple math question",
        new anchor.BN(0),
        "",
        ""
      )
      .accounts({
        question: questionKeypair.publicKey,
        user: program.provider.publicKey!,
      })
      .signers([questionKeypair])
      .rpc();

    // Place a bet
    const betKeypair = anchor.web3.Keypair.generate();
    const betChoice = true;
    const betAmount = new anchor.BN(500);

    await program.methods
      .placeBet(betChoice, betAmount)
      .accounts({
        question: questionKeypair.publicKey,
        bet: betKeypair.publicKey,
        user: program.provider.publicKey!,
      })
      .signers([betKeypair])
      .rpc();

    // Fetch bet and question accounts
    const betAcct = await program.account.bet.fetch(betKeypair.publicKey);
    const q = await program.account.question.fetch(questionKeypair.publicKey);

    assert.strictEqual(betAcct.answer, betChoice);
    // payout calculation in program currently returns amount; map to BN
    assert.ok(betAcct.payout.eq(betAmount));
    assert.ok(betAcct.ownerWallet.equals(program.provider.publicKey!));

    // The question's bets vector should include the bet (depends on implementation details)
    // At minimum, ensure bets length is > 0 and that owner_wallet is set on question
    assert.ok(Array.isArray(q.bets));
    console.log("Owner wallet:", q.ownerWallet.toBase58());
    console.log("Provider pubkey:", program.provider.publicKey!.toBase58());
    assert.ok(q.ownerWallet.equals(program.provider.publicKey!));

    // check vote counts
    if (betChoice) {
      assert.ok(q.yesVotes.eq(betAmount));
      assert.ok(q.noVotes.eq(new anchor.BN(0)));
    } else {
      assert.ok(q.noVotes.eq(betAmount));
      assert.ok(q.yesVotes.eq(new anchor.BN(0)));
    }
  });

});
